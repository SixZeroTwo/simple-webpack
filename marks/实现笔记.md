# 打包过程

## 根据文件构建图

### 读取单个文件的内容和依赖

先从最简单的情况开始，我们要打包的代码入口文件是 `main.js`，它依赖了一个`foo.js`。（node中使用esm规范，需要再package.json中配置type为module）

```js
//main.js
import {foo} from './foo.js'
console.log('main');
foo()

//foo.js
export function foo() {
  console.log('foo');
}
```

我们代码所要实现的第一个功能：针对每个文件，生成一个对象来记录这个文件的抽象语法对象和依赖，我们需要借助`@babel/parser`来帮助我们快速生成抽象语法树。

```ts
import fs from 'fs'
import parser from '@babel/parser'
function createAsset() {
  const source = fs.readFileSync('./examples/main.js', {
    encoding: 'utf-8'
  })
  const ast = parser.parse(source, { sourceType: 'module' })
  return {
  }
}

createAsset()
```

之后需要根据创建的`ast`记录该文件的依赖关系，也就是需要找到该文件引用了哪些其它文件，可以看到`ast`对象内部有`importDeclaration`属性记录了导入的路径，我们借助[`@babel/traverse`](https://babel.docschina.org/docs/en/babel-traverse/)遍历该`ast`对象，取出依赖项的相对路径。

![image-20220725113403419](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220725113403419.png)

```js
import fs from 'fs'
import parser from '@babel/parser'
import traverse from '@babel/traverse'
function createAsset(filePath) {
  //读取文件内容，解码成字符串
  const source = fs.readFileSync(filePath, {
    encoding: 'utf-8'
  })
  //将文件内容转换成抽象语法树
  const ast = parser.parse(source, { sourceType: 'module' })
  const deps = []
  traverse.default(ast, {
    ImportDeclaration(path) {
      deps.push(path.node.source.value)
    }
  })
  return {
  	filePath,
    source,
    deps
  }
}

const asset = createAsset('./examples/main.js')
```

### 根据入口文件创建图

这部分就是利用入口文件路径和队列实现的图的**BFS**搜索，返回了一个队列作为图的表示。

```ts
//创建图
function createGraph() {
  const mainAsset = createAsset('./examples/main.js')
  const queue = [mainAsset]
  const res = []
  while (queue.length) {
    for (let i = 0; i < queue.length; i++) {
      const shiftAsset = queue.shift()
      res.push(shiftAsset)
      const relativePaths = shiftAsset.deps
      for (let relativePath of relativePaths) {
        const child = createAsset(path.resolve('./examples/', relativePath))
        queue.push(child)
      }
    }
  }
  return res
}

const graph = createGraph()
```

## 根据图打包文件

### 打包的结果是啥样的——What？

我们首先将main.js和foo.js的打包结果放到bundle.js里面，在构建我们的打包代码之前，看看我们打包出的结果应该是啥样的——我称之为**打包结果模板**：

```js
//foo.js
import foo from './foo.js'

console.log('main');
foo()

//main.js
export function foo() {
  console.log('foo');
}
```

首先，我们要考虑变量相互污染的问题——可以利用函数将各个文件的作用域隔离起来。其次，原有的import语句export语句肯定不能继续使用了（函数体内不能使用import和export）——在这里我们借鉴**commonJS**规范，实现一个**require**函数用于帮助我们**导入**所需的变量。

```js
//main.js
function mainjs(require, module) {
  const { foo } = require('./foo.js')

  console.log('main');
  foo()
}


//foo.js
function foojs(require, module) {
  function foo() {
    console.log('foo');
  }
  module.exports = {
    foo
  }
}


function require(filePath) {
  const fileMapFunction = {
    './foo.js': foojs
  }
  const fn = fileMapFunction[filePath]
  const module = {
    exports: {}
  }
  fn(require, module)
  return module.exports
}

mainjs(require)
```

之后重构一下这段代码，从入口开始执行，将路径映射到对应函数的表作为参数传入立即执行函数，这样变动的点就只有这张表以及入口文件了：

```js
(function (fileMapFunction) {
  function require(filePath) {
    const fn = fileMapFunction[filePath]
    const module = {
      exports: {}
    }
    fn(require, module)
    return module.exports
  }
  //入口
  require('./main.js')
})({
  './foo.js': function foojs(require, module) {
    function foo() {
      console.log('foo');
    }
    module.exports = {
      foo
    }
  },
  './main.js': function mainjs(require, module) {
    const { foo } = require('./foo.js')

    console.log('main');
    foo()
  }
})
```

### 打包的结果是咋得到的——How？

了解了打包结果文件的变动点（路径->函数的映射表以及入口文件）之后，我们可以通过字符串拼接或模板生成器的方式来得到打包文件。在这里我们采用的是第二种方法——使用了**[ejs模板生成器](https://ejs.bootcss.com/#install)**：

我们的ejs模板如下：

```js
//bundle.ejs
(function (fileMapFunction) {
function require(filePath) {
const fn = fileMapFunction[filePath]
const module = {
exports: {}
}
fn(require, module)
return module.exports
}
//入口
require('./main.js')
})({
//data数组是我们需要进行处理得到的数据，每个元素的filePath和code分别映射到该对象的key和函数体
<% data.forEach(info=>{ %>
  '<%- info.filePath %>': function (require, module) {
    <%- info.code; %>
      },
      <%}) %>
        });
```

在这里我们需要得到原文件的commonJS规范形式，可以借助babe-core的`transformFromAst`api（注意：如果在presets中加上了env，需要依赖`babel-presets-env`），用于帮助我们从ast生成对应的commonJS规范的文件内容。

```js
import { transformFromAst } from 'babel-core'
function createAsset(filePath) {
  //...处理ast和deps的过程	
  const { code } = transformFromAst(ast, null, { presets: ["env"] })
  return {
    filePath,
    code,
    deps
  }
}
```

至此，我们得到了commJS版本的文件内容，将其映射成ejs模板需要的data：

```js
function build(graph) {
  const template = fs.readFileSync('bundle.ejs', { encoding: 'utf-8' })
  const data = graph.map(asset => {
    return {
      filePath: asset.filePath,
      code: asset.code,
    }
  })
  //ejs能够通过模板和data得到对应的字符串
  const code = ejs.render(template, { data })
  //将打包后的内容写入
  fs.writeFileSync('./dist/bundle.js', code)
}

build(graph)
```

最终得到的结果如下：

```js
(function (fileMapFunction) {
  function require(filePath) {
    const fn = fileMapFunction[filePath]
    const module = {
      exports: {}
    }
    fn(require, module)
    return module.exports
  }
  //入口
  require('./main.js')
})({

  './examples/main.js': function (require, module) {
    "use strict";

    var _foo = require("./foo.js");

    var _foo2 = _interopRequireDefault(_foo);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    console.log('main');
    (0, _foo2.default)();
  },
  'C:\Users\Administrator\Desktop\自学前端\webpack\simple-webpack\examples\foo.js': function (require, module) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.foo = foo;

    function foo() {
      console.log('foo');
    }
  }
})
```

### 存在的问题——相对路径映射可能会冲突

可以看到在main函数中是通过**相对路径**请求的foo函数，而在map中的key是**绝对路径**。我们在data数据处理的时候统一改成相对路径——这会带来一个问题，如果有另外的子文件夹下面也存在先main和foo这样的引用关系的话，map就会发生错误的映射。

我们的解决办法是：修改key的命名方式——利用唯一id作为key，在每个模块内记录请求路径对应的id值来找到对应的模块，对应的模板如下：

```js
(function (fileMapFunction) {
  function require(id) {
    const fn = fileMapFunction[id][0]
    const map = fileMapFunction[id][1]
    const module = {
      exports: {}
    }

    const localRequire = function (filePath) {
      const localId = map[filePath]
      return require(localId)
    }
    fn(localRequire, module)
    return module.exports
  }
  //入口
  require(1)
})({
  1: [function mainjs(require, module) {
    const { foo } = require('./foo.js')

    console.log('main');
    foo()
  }, {
    './foo.js': 2
  }],
  2: [function foojs(require, module) {
    function foo() {
      console.log('foo');
    }
    module.exports = {
      foo
    }
  }, {}],
})
```

其中由于require的请求参数变成了id，因此定义了一个localRequire进行转换（相当于一个装饰器）。

接下来我们将这份结果替换到ejs文件里面（**注意这里函数的参数加上了exports，因为经过转译后的函数内容用到了exports**）：

```js
(function (fileMapFunction) {
function require(id) {
const fn = fileMapFunction[id][0]
const map = fileMapFunction[id][1]
const module = {
exports: {}
}
const localRequire = function (filePath) {
const localId = map[filePath]
return require(localId)
}
fn(localRequire, module,module.exports)
return module.exports
}
//入口
require(1)
})({
<% data.forEach(info=>{ %>
  <%- info.id %>: [function (require, module,exports) {
    <%- info.code; %>
      },
      <%- JSON.stringify(info.mapping) %>
        ],
        <%}) %>
          });
```

新的模板结果有了，我们接下来就是思考该如何实现：

1.怎么拿到唯一的**模块id**作为key值

2.得到data的mapping的键值对为**相对路径**：**模块id**

对于第一点，我们可以在创建模块（createAsset）时递增地得赋予一个全局变量id。

```js
let id = 1
function createAsset(filePath) {
  //...
  return {
    filePath,
    code,
    deps,
    id: id++，
    mapping:{},
  }
}
```

对于第二点，我们可以在构建图的过程中，在根据**相对路径**创建完**依赖模块**之后指定**相对路径**的**模块id**指向：

```js
function createGraph() {
  const mainAsset = createAsset('./examples/main.js')
  const queue = [mainAsset]
  for (let asset of queue) {
    const relativePaths = asset.deps
    for (let relativePath of relativePaths) {
      const child = createAsset(path.resolve('./examples/', relativePath))
      //指定**相对路径**的**模块id**指向
      asset.mapping[relativePath] = child.id
      queue.push(child)
    }
  }
  return queue
}
```

最后执行打包过程，得到打包文件：

```js
(function (fileMapFunction) {
  function require(id) {
    const fn = fileMapFunction[id][0]
    const map = fileMapFunction[id][1]
    const module = {
      exports: {}
    }
    const localRequire = function (filePath) {
      const localId = map[filePath]
      return require(localId)
    }
    fn(localRequire, module, module.exports)
    return module.exports
  }
  //入口
  require(1)
})({

  1: [function (require, module, exports) {
    "use strict";

    var _foo = require("./foo.js");

    var _foo2 = _interopRequireDefault(_foo);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    console.log('main');
    (0, _foo2.default)();
  },
  { "./foo.js": 2 }
  ],

  2: [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.foo = foo;

    function foo() {
      console.log('foo');
    }
  },
  {}
  ],
});
```

### 扩展问题——循环引用的破解

# loader
