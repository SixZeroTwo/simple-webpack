# 打包过程

## 根据文件构建图

### 读取单个文件的内容和依赖

先从最简单的情况开始，我们要打包的代码入口文件是 `main.js`，它依赖了一个`foo.js`。（node中使用esm规范，需要再package.json中配置type为module）

```js
//main.js
import foo from './foo.js'
console.log('main');
foo()

//foo.js
export function foo() {
  console.log('foo');
}
```

我们代码所要实现的第一个功能：针对每个文件，生成一个对象来记录这个文件的抽象语法对象和依赖，我们需要借助`@babel/parser`来帮助我们快速生成抽象语法树。

```ts
import fs from 'fs'
import parser from '@babel/parser'
function createAsset() {
  const source = fs.readFileSync('./examples/main.js', {
    encoding: 'utf-8'
  })
  const ast = parser.parse(source, { sourceType: 'module' })
  return {
  }
}

createAsset()
```

之后需要根据创建的`ast`记录该文件的依赖关系，也就是需要找到该文件引用了哪些其它文件，可以看到`ast`对象内部有`importDeclaration`属性记录了导入的路径，我们借助[`@babel/traverse`](https://babel.docschina.org/docs/en/babel-traverse/)遍历该`ast`对象，取出依赖项的相对路径。

![image-20220725113403419](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220725113403419.png)

```js
import fs from 'fs'
import parser from '@babel/parser'
import traverse from '@babel/traverse'
function createAsset(filePath) {
  //读取文件内容，解码成字符串
  const source = fs.readFileSync(filePath, {
    encoding: 'utf-8'
  })
  //将文件内容转换成抽象语法树
  const ast = parser.parse(source, { sourceType: 'module' })
  const deps = []
  traverse.default(ast, {
    ImportDeclaration(path) {
      deps.push(path.node.source.value)
    }
  })
  return {
  	filePath,
    source,
    deps
  }
}

const asset = createAsset('./examples/main.js')
```

### 根据入口文件创建图

这部分就是利用入口文件路径和队列实现的图的**BFS**搜索，返回了一个队列作为图的表示。

```ts
//创建图
function createGraph() {
  const mainAsset = createAsset('./examples/main.js')
  const queue = [mainAsset]
  const res = []
  while (queue.length) {
    for (let i = 0; i < queue.length; i++) {
      const shiftAsset = queue.shift()
      res.push(shiftAsset)
      const relativePaths = shiftAsset.deps
      for (let relativePath of relativePaths) {
        const child = createAsset(path.resolve('./examples/', relativePath))
        queue.push(child)
      }
    }
  }
  return res
}

const graph = createGraph()
```

## 根据图打包文件

### 打包的结果是啥样的？

我们首先将main.js和foo.js的打包结果放到bundle.js里面，在构建我们的打包代码之前，看看我们打包出的结果应该是啥样的：

```js
//foo.js
import foo from './foo.js'

console.log('main');
foo()

//main.js
export function foo() {
  console.log('foo');
}
```

首先，我们要考虑变量相互污染的问题——可以利用函数将各个文件的作用域隔离起来。其次，原有的import语句export语句肯定不能继续使用了——在这里我们借鉴**commonJS**规范，实现一个**require**函数用于帮助我们**导入**所需的变量。

```js
//main.js
function mainjs(require, module) {
  const { foo } = require('./foo.js')

  console.log('main');
  foo()
}


//foo.js
function foojs(require, module) {
  function foo() {
    console.log('foo');
  }
  module.exports = {
    foo
  }
}


function require(filePath) {
  const fileMapFunction = {
    './foo.js': foojs
  }
  const fn = fileMapFunction[filePath]
  const module = {
    exports: {}
  }
  fn(require, module)
  return module.exports
}

mainjs(require)
```

之后重构一下这段代码，从入口开始执行，将路径映射到对应函数的表作为参数传入立即执行函数，这样变动的点就只有这张表以及入口文件了：

```js
(function (fileMapFunction) {
  function require(filePath) {
    const fn = fileMapFunction[filePath]
    const module = {
      exports: {}
    }
    fn(require, module)
    return module.exports
  }
  //入口
  require('./main.js')
})({
  './foo.js': function foojs(require, module) {
    function foo() {
      console.log('foo');
    }
    module.exports = {
      foo
    }
  },
  './main.js': function mainjs(require, module) {
    const { foo } = require('./foo.js')

    console.log('main');
    foo()
  }
})
```

